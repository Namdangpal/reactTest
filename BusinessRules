🔹 최종 업무규칙 요약
1. 대상항목 중심 구조

점검계획과 점검일정은 대상항목(Target) 기준으로 관리

계획에 종속되지 않고, 일정과 체크항목은 대상항목 중심으로 생성

비정형/특수점검은 별도 관리, 필요시 병합 가능

2. 복합주기 지원

대상항목은 여러 점검주기(1M, 3M, 6M, 12M 등)를 가질 수 있음

DB상 일정은 하나로 통합, 주기별 체크항목 배열로 관리

복합주기 일정도 이월 시 동일 단일 일정 레코드 내에서 처리

3. 점검일정 생성

초기 1년치 점검일정을 선생성 → 이후 매월 1년치 유지

DB상 일정 단일화 → 동일 날짜 주기별 일정 병합

신규 일정이 필요하면 자동 생성 후 이월 항목 병합 가능

4. 이월(Carry Over) 규칙

미이행 일정 → 다음 달로 이월

복합주기 대상항목의 모든 일정도 같이 이월

단일 일정 레코드 유지, status='CARRIED_OVER', carried_from 추적

연쇄 이월 가능, 장기 미이행은 관리자 확인 필요

5. 주기 변경 및 충돌 처리

일정 단일화 덕분에 날짜 중복 문제 없음

주기 변경 시 체크항목 배열 내 수정만 수행

UI/보고서에서 복합주기 일정 표시, 필요 시 병합

6. 운영 정책

사용되지 않는 일정 폐기/보관

배치 자동화: 매월 이월, 1년치 일정 유지, 신규 일정 생성

보고/통계: 단일 일정 기준 완료율, 이월율, 연체율 계산 용이

NoSQL/RDB 모두 적용 가능, 대량 데이터 처리 가능

🔹 장점
장점	설명
단순성	DB상 일정 단일화, 이월 로직 명확
복합주기 처리	주기별 체크항목 단일 일정에서 관리 → UI/보고 단순화
유연성	신규 일정 생성, 연쇄 이월, 특수점검 처리 가능
운영 편의성	관리자/점검자 이해 쉬움, 배치 자동화 용이
데이터 정합성	이월 체인 및 체크항목 추적 가능, 통계 정확성 확보
🔹 최종 평가

논리적 구조: 대상항목 중심 + 일정 단일화 + 주기별 체크항목 배열 → 매우 합리적

운영 효율성: 이월, 배치, 보고/통계 처리 모두 단순화

확장성: 주기 추가, 특수점검, 대규모 데이터 처리 가능

단점/주의점:

연쇄 이월이 장기화될 경우 관리 필요

복합주기 체크항목 관리 로직은 UI/배치에서 주의 필요

💡 결론:

현재 정리된 업무규칙은 단순성과 유연성을 모두 갖춘 구조입니다.

DB 설계와 배치/UI 설계를 적절히 연동하면 실제 운영에서 매우 효율적으로 적용 가능

NoSQL과 RDB 모두 구현 가능하며, 대량 데이터와 복합주기 상황에서도 안정적 처리 가능
