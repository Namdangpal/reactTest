-- gen_inspect_schedule_oracle11g.sql
-- Oracle 11g 호환: GTT 기반 점검일정 생성 스크립트
-- 사용 전: DBA 권한 확인 후 실행하세요 (임시테이블 생성 권한 필요)

-- 0. 기존 객체 제거(테스트 환경에서만 사용)
BEGIN
    EXECUTE IMMEDIATE 'DROP PROCEDURE GEN_INSPECT_SCHEDULE_GTT';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE TB_INSPECT_SCHEDULE';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE TB_INSPECT_ITEM';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
BEGIN
    EXECUTE IMMEDIATE 'DROP TABLE TMP_SCHEDULE_GEN';
EXCEPTION WHEN OTHERS THEN NULL;
END;
/
-- 1. 운영 테이블 생성
CREATE TABLE TB_INSPECT_ITEM (
    ITEM_ID       NUMBER PRIMARY KEY,
    ITEM_NAME     VARCHAR2(200),
    START_DATE    DATE,            -- 반복 기준 시작일(예: 2025-01-05)
    BASE_DAY      NUMBER DEFAULT 1,
    BASE_MONTH    NUMBER DEFAULT 1,
    REPEAT_CYCLE  VARCHAR2(100)    -- 예: '2W,1M,3M,6M,12M' (콤마구분)
);
/
CREATE TABLE TB_INSPECT_SCHEDULE (
    SCHEDULE_ID   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ITEM_ID       NUMBER,
    SCHEDULE_DATE DATE,
    CYCLE_CODE    VARCHAR2(100),
    CREATED_AT    DATE DEFAULT SYSDATE,
    UPDATED_AT    DATE,
    CONSTRAINT FK_ITEM FOREIGN KEY (ITEM_ID) REFERENCES TB_INSPECT_ITEM(ITEM_ID)
);
/
-- 2. 글로벌 임시테이블 (GTT)
CREATE GLOBAL TEMPORARY TABLE TMP_SCHEDULE_GEN (
    ITEM_ID       NUMBER,
    SCHEDULE_DATE DATE,
    CYCLE_CODE    VARCHAR2(100)
) ON COMMIT DELETE ROWS;
/
-- 3. 프로시저: p_start_date, p_end_date 범위의 일정 생성 및 TB_INSPECT_SCHEDULE에 반영
CREATE OR REPLACE PROCEDURE GEN_INSPECT_SCHEDULE_GTT(
    p_start_date IN DATE,
    p_end_date   IN DATE
)
AS
BEGIN
    -- 초기화
    DELETE FROM TMP_SCHEDULE_GEN;

    ------------------------------------------------------------------
    -- 2W 일정 생성: 각 항목에서 2주 간격으로 p_start_date 기준 생성
    ------------------------------------------------------------------
    INSERT INTO TMP_SCHEDULE_GEN (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE)
    SELECT itm.ITEM_ID,
           (TRUNC(p_start_date, 'MM') + (NVL(itm.BASE_DAY,1)-1)) + (LEVEL-1)*14 AS SCHEDULE_DATE,
           '2W'
    FROM TB_INSPECT_ITEM itm
    WHERE INSTR(itm.REPEAT_CYCLE,'2W') > 0
    CONNECT BY (TRUNC(p_start_date, 'MM') + (NVL(itm.BASE_DAY,1)-1)) + (LEVEL-1)*14 <= p_end_date
           AND PRIOR itm.ITEM_ID = itm.ITEM_ID
           AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;

    ------------------------------------------------------------------
    -- 1M 일정 (2W 없는 항목에 대해서만 월단위 생성)
    ------------------------------------------------------------------
    INSERT INTO TMP_SCHEDULE_GEN (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE)
    SELECT itm.ITEM_ID,
           ADD_MONTHS(TRUNC(p_start_date,'MM') + (NVL(itm.BASE_DAY,1)-1), LEVEL-1) AS SCHEDULE_DATE,
           '1M'
    FROM TB_INSPECT_ITEM itm
    WHERE INSTR(itm.REPEAT_CYCLE,'1M') > 0
      AND INSTR(itm.REPEAT_CYCLE,'2W') = 0
    CONNECT BY ADD_MONTHS(TRUNC(p_start_date,'MM') + (NVL(itm.BASE_DAY,1)-1), LEVEL-1) <= p_end_date
           AND PRIOR itm.ITEM_ID = itm.ITEM_ID
           AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;

    ------------------------------------------------------------------
    -- 3M,6M,12M 생성: BASE_MONTH & BASE_DAY 기준으로 반복
    ------------------------------------------------------------------
    DECLARE
        v_cycle VARCHAR2(3);
    BEGIN
        FOR rec IN (SELECT ITEM_ID, BASE_DAY, BASE_MONTH, REPEAT_CYCLE FROM TB_INSPECT_ITEM WHERE REPEAT_CYCLE IS NOT NULL) LOOP
            -- 3M
            IF INSTR(rec.REPEAT_CYCLE,'3M') > 0 THEN
                INSERT INTO TMP_SCHEDULE_GEN (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE)
                SELECT rec.ITEM_ID,
                       ADD_MONTHS(TRUNC(p_start_date,'YYYY') + (NVL(rec.BASE_DAY,1)-1), (rec.BASE_MONTH-1) + (LEVEL-1)*3) AS SCHEDULE_DATE,
                       '3M'
                FROM DUAL
                CONNECT BY ADD_MONTHS(TRUNC(p_start_date,'YYYY') + (NVL(rec.BASE_DAY,1)-1), (rec.BASE_MONTH-1) + (LEVEL-1)*3) <= p_end_date;
            END IF;

            -- 6M
            IF INSTR(rec.REPEAT_CYCLE,'6M') > 0 THEN
                INSERT INTO TMP_SCHEDULE_GEN (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE)
                SELECT rec.ITEM_ID,
                       ADD_MONTHS(TRUNC(p_start_date,'YYYY') + (NVL(rec.BASE_DAY,1)-1), (rec.BASE_MONTH-1) + (LEVEL-1)*6) AS SCHEDULE_DATE,
                       '6M'
                FROM DUAL
                CONNECT BY ADD_MONTHS(TRUNC(p_start_date,'YYYY') + (NVL(rec.BASE_DAY,1)-1), (rec.BASE_MONTH-1) + (LEVEL-1)*6) <= p_end_date;
            END IF;

            -- 12M (연 1회 기준: BASE_MONTH에서 시작)
            IF INSTR(rec.REPEAT_CYCLE,'12M') > 0 THEN
                INSERT INTO TMP_SCHEDULE_GEN (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE)
                VALUES (rec.ITEM_ID, ADD_MONTHS(TRUNC(p_start_date,'YYYY') + (NVL(rec.BASE_DAY,1)-1), rec.BASE_MONTH-1), '12M');
            END IF;
        END LOOP;
    END;

    ------------------------------------------------------------------
    -- 2W 포함 항목: 해당 월 첫 2W에만 1M 병합 (1M 단독은 삭제)
    ------------------------------------------------------------------
    DELETE FROM TMP_SCHEDULE_GEN t1
     WHERE t1.CYCLE_CODE = '1M'
       AND EXISTS (
           SELECT 1 FROM (
               SELECT ITEM_ID, SCHEDULE_DATE, ROW_NUMBER() OVER (PARTITION BY ITEM_ID, TO_CHAR(SCHEDULE_DATE,'YYYYMM') ORDER BY SCHEDULE_DATE) AS RN
               FROM TMP_SCHEDULE_GEN
               WHERE CYCLE_CODE = '2W'
           ) t2
           WHERE t2.ITEM_ID = t1.ITEM_ID
             AND t2.RN = 1
             AND TO_CHAR(t2.SCHEDULE_DATE,'YYYYMM') = TO_CHAR(t1.SCHEDULE_DATE,'YYYYMM')
             AND t2.SCHEDULE_DATE = (
                 SELECT MIN(s3.SCHEDULE_DATE) FROM TMP_SCHEDULE_GEN s3
                  WHERE s3.ITEM_ID = t1.ITEM_ID AND s3.CYCLE_CODE = '2W' AND TO_CHAR(s3.SCHEDULE_DATE,'YYYYMM') = TO_CHAR(t1.SCHEDULE_DATE,'YYYYMM')
             )
       );

    -- 위 삭제는 2W가 있는 달에서 1M을 남기지 않기 위한 전처리.
    -- 대신 첫 2W 행에 '2W,1M'으로 합치는 작업을 아래에서 수행.

    ------------------------------------------------------------------
    -- 첫 2W 행에 1M을 합침: 업데이트
    ------------------------------------------------------------------
    MERGE INTO TMP_SCHEDULE_GEN tgt
    USING (
        SELECT t.ITEM_ID, MIN(t.SCHEDULE_DATE) AS FIRST_2W_DATE, TO_CHAR(MIN(t.SCHEDULE_DATE),'YYYYMM') AS YM
        FROM TMP_SCHEDULE_GEN t
        WHERE t.CYCLE_CODE = '2W'
        GROUP BY t.ITEM_ID, TO_CHAR(t.SCHEDULE_DATE,'YYYYMM')
    ) src
    ON (tgt.ITEM_ID = src.ITEM_ID AND tgt.SCHEDULE_DATE = src.FIRST_2W_DATE)
    WHEN MATCHED THEN UPDATE SET tgt.CYCLE_CODE = '2W,1M';

    ------------------------------------------------------------------
    -- 동일 날짜의 여러 CYCLE_CODE를 합쳐 하나의 행으로 만들고 실제 테이블에 반영
    ------------------------------------------------------------------
    MERGE INTO TB_INSPECT_SCHEDULE tgt
    USING (
        SELECT ITEM_ID, SCHEDULE_DATE,
               LISTAGG(CYCLE_CODE, ',') WITHIN GROUP (ORDER BY CYCLE_CODE) AS CYCLE_CODES
          FROM TMP_SCHEDULE_GEN
         GROUP BY ITEM_ID, SCHEDULE_DATE
    ) src
    ON (tgt.ITEM_ID = src.ITEM_ID AND tgt.SCHEDULE_DATE = src.SCHEDULE_DATE)
    WHEN MATCHED THEN
      UPDATE SET tgt.CYCLE_CODE = src.CYCLE_CODES, tgt.UPDATED_AT = SYSDATE
    WHEN NOT MATCHED THEN
      INSERT (ITEM_ID, SCHEDULE_DATE, CYCLE_CODE) VALUES (src.ITEM_ID, src.SCHEDULE_DATE, src.CYCLE_CODES);

    COMMIT;

EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        RAISE;
END GEN_INSPECT_SCHEDULE_GTT;
/

-- 4. 샘플 데이터 삽입
INSERT INTO TB_INSPECT_ITEM (ITEM_ID, ITEM_NAME, START_DATE, BASE_DAY, BASE_MONTH, REPEAT_CYCLE)
VALUES (101, '소화전', DATE '2025-01-01', 2, 1, '2W,1M,3M,6M,12M');
INSERT INTO TB_INSPECT_ITEM (ITEM_ID, ITEM_NAME, START_DATE, BASE_DAY, BASE_MONTH, REPEAT_CYCLE)
VALUES (102, '스프링클러', DATE '2025-01-01', 5, 1, '1M,3M');
INSERT INTO TB_INSPECT_ITEM (ITEM_ID, ITEM_NAME, START_DATE, BASE_DAY, BASE_MONTH, REPEAT_CYCLE)
VALUES (103, '밸브', DATE '2025-01-01', 10, 1, '2W,1M');
INSERT INTO TB_INSPECT_ITEM (ITEM_ID, ITEM_NAME, START_DATE, BASE_DAY, BASE_MONTH, REPEAT_CYCLE)
VALUES (104, '감지기', DATE '2025-01-01', 15, 2, '1M,6M');
INSERT INTO TB_INSPECT_ITEM (ITEM_ID, ITEM_NAME, START_DATE, BASE_DAY, BASE_MONTH, REPEAT_CYCLE)
VALUES (105, '전원', DATE '2025-01-01', 20, 3, '3M,12M');
COMMIT;

-- 5. 프로시저 실행 (예: 2025년 범위)
BEGIN
    GEN_INSPECT_SCHEDULE_GTT(DATE '2025-01-01', DATE '2025-12-31');
END;
/

-- 6. 결과 확인 (JSON 형태 간단 생성)
-- Oracle 11g에는 JSON 함수가 없으므로 문자열로 생성
SET SERVEROUTPUT ON SIZE 2000000;
DECLARE
    v_json CLOB := '[';
BEGIN
    FOR r IN (
        SELECT ITEM_ID,
               TO_CHAR(SCHEDULE_DATE,'YYYY-MM-DD') AS SCHEDULE_DATE,
               CYCLE_CODE
          FROM TB_INSPECT_SCHEDULE
         ORDER BY ITEM_ID, SCHEDULE_DATE
    ) LOOP
        v_json := v_json || '{"ITEM_ID":' || r.ITEM_ID || ',"SCHEDULE_DATE":"' || r.SCHEDULE_DATE || '","CYCLE_CODE":"' || r.CYCLE_CODE || '"},';
    END LOOP;
    v_json := RTRIM(v_json, ',') || ']';
    DBMS_OUTPUT.PUT_LINE(v_json);
END;
/
-- 끝
