CREATE OR REPLACE PROCEDURE GEN_INSPECTION_SCHEDULE_FIXED_BASEMONTH(
    P_START_DATE IN DATE,
    P_END_DATE   IN DATE
)
AS
BEGIN
    -- 임시 테이블 생성
    EXECUTE IMMEDIATE 'CREATE GLOBAL TEMPORARY TABLE TMP_INSPECTION_SCHEDULE
        (ITEM_ID NUMBER,
         INSPECTION_DATE DATE,
         CYCLE_TYPE VARCHAR2(20))
        ON COMMIT DELETE ROWS';

    -- 2W 일정 생성
    INSERT INTO TMP_INSPECTION_SCHEDULE(ITEM_ID, INSPECTION_DATE, CYCLE_TYPE)
    SELECT ITEM_ID,
           P_START_DATE + (LEVEL-1)*14 AS INSPECTION_DATE,
           '2W'
      FROM INSPECTION_ITEM
     WHERE INSTR(CYCLE_TYPES,'2W') > 0
     CONNECT BY P_START_DATE + (LEVEL-1)*14 <= P_END_DATE
           AND PRIOR ITEM_ID = ITEM_ID
           AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;

    -- 2W 포함 항목 각 월 첫 2W에 1M 병합
    MERGE INTO TMP_INSPECTION_SCHEDULE T
    USING (
        SELECT ITEM_ID,
               MIN(INSPECTION_DATE) AS FIRST_2W_DATE
          FROM TMP_INSPECTION_SCHEDULE
         WHERE CYCLE_TYPE = '2W'
         GROUP BY ITEM_ID, TO_CHAR(INSPECTION_DATE,'YYYYMM')
    ) F
    ON (T.ITEM_ID = F.ITEM_ID AND T.INSPECTION_DATE = F.FIRST_2W_DATE)
    WHEN MATCHED THEN
        UPDATE SET T.CYCLE_TYPE = '2W,1M';

    -- 2W 없는 항목 1M 일정 생성
    INSERT INTO TMP_INSPECTION_SCHEDULE(ITEM_ID, INSPECTION_DATE, CYCLE_TYPE)
    SELECT ITEM_ID,
           ADD_MONTHS(TRUNC(P_START_DATE,'MM') + (NVL(BASE_DAY,2)-1), LEVEL-1) AS INSPECTION_DATE,
           '1M'
      FROM INSPECTION_ITEM
     WHERE INSTR(CYCLE_TYPES,'1M') > 0
       AND INSTR(CYCLE_TYPES,'2W') = 0
     CONNECT BY ADD_MONTHS(TRUNC(P_START_DATE,'MM') + (NVL(BASE_DAY,2)-1), LEVEL-1) <= P_END_DATE
           AND PRIOR ITEM_ID = ITEM_ID
           AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;

    -- 3M,6M,12M 일정 생성 (BASE_MONTH 기준)
    FOR CYCLE IN ('3M','6M','12M') LOOP
        INSERT INTO TMP_INSPECTION_SCHEDULE(ITEM_ID, INSPECTION_DATE, CYCLE_TYPE)
        SELECT ITEM_ID,
               ADD_MONTHS(
                   TRUNC(P_START_DATE,'YYYY') + (NVL(BASE_DAY,2)-1),
                   (LEVEL-1) * CASE CYCLE
                                  WHEN '3M' THEN 3
                                  WHEN '6M' THEN 6
                                  WHEN '12M' THEN 12
                              END
                   + (BASE_MONTH - 1)
               ) AS INSPECTION_DATE,
               CYCLE AS CYCLE_TYPE
          FROM INSPECTION_ITEM
         WHERE INSTR(CYCLE_TYPES, CYCLE) > 0
           AND (CYCLE != '12M' OR BASE_MONTH = 1)
         CONNECT BY ADD_MONTHS(
                     TRUNC(P_START_DATE,'YYYY') + (NVL(BASE_DAY,2)-1),
                     (LEVEL-1) * CASE CYCLE
                                    WHEN '3M' THEN 3
                                    WHEN '6M' THEN 6
                                    WHEN '12M' THEN 12
                                END
                     + (BASE_MONTH - 1)
                   ) <= P_END_DATE
               AND PRIOR ITEM_ID = ITEM_ID
               AND PRIOR DBMS_RANDOM.VALUE IS NOT NULL;
    END LOOP;

    -- 최종 INSPECTION_SCHEDULE에 MERGE
    MERGE INTO INSPECTION_SCHEDULE TGT
    USING (
        SELECT ITEM_ID, INSPECTION_DATE,
               LISTAGG(CYCLE_TYPE, ',') WITHIN GROUP (ORDER BY CYCLE_TYPE) AS CYCLE_TYPES
          FROM TMP_INSPECTION_SCHEDULE
         GROUP BY ITEM_ID, INSPECTION_DATE
    ) SRC
    ON (TGT.ITEM_ID = SRC.ITEM_ID AND TGT.INSPECTION_DATE = SRC.INSPECTION_DATE)
    WHEN MATCHED THEN
        UPDATE SET TGT.CYCLE_TYPES = SRC.CYCLE_TYPES,
                   TGT.UPDATED_AT = SYSDATE
    WHEN NOT MATCHED THEN
        INSERT (ITEM_ID, INSPECTION_DATE, CYCLE_TYPES, STATUS)
        VALUES (SRC.ITEM_ID, SRC.INSPECTION_DATE, SRC.CYCLE_TYPES, '점검전');

    COMMIT;

    -- 임시 테이블 삭제
    EXECUTE IMMEDIATE 'DROP TABLE TMP_INSPECTION_SCHEDULE';
EXCEPTION
    WHEN OTHERS THEN
        ROLLBACK;
        DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
END;
/
